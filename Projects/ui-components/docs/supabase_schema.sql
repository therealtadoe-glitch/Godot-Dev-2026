-- Wallace Commercial Landscaping operations schema
-- Target: Supabase Postgres

-- Extensions
create extension if not exists pgcrypto;

-- Enums
create type public.app_role as enum ('ADMIN', 'CREW_LEAD', 'EMPLOYEE', 'MECHANIC');
create type public.ticket_status as enum ('TODO', 'IN_PROGRESS', 'COMPLETE');
create type public.work_type as enum ('MOWING', 'PRUNING', 'LEAF_PICKUP', 'IRRIGATION', 'TRASH', 'MULCH', 'OTHER');
create type public.equipment_category as enum ('GAS_EQUIPMENT', 'CHEMICAL', 'TOOL');
create type public.equipment_condition as enum ('GOOD', 'NEEDS_SERVICE', 'OUT_OF_SERVICE', 'DAMAGED');
create type public.repair_status as enum ('OPEN', 'DIAGNOSING', 'WAITING_PARTS', 'IN_REPAIR', 'RESOLVED', 'CLOSED');

-- Core identity/profile table linked to auth.users
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  email text not null unique,
  full_name text not null,
  role public.app_role not null default 'EMPLOYEE',
  phone text,
  is_active boolean not null default true,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.crews (
  id uuid primary key default gen_random_uuid(),
  name text not null unique,
  lead_user_id uuid references public.profiles(user_id) on delete set null,
  created_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.villages (
  id uuid primary key default gen_random_uuid(),
  name text not null unique,
  area_code text,
  is_active boolean not null default true,
  created_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.job_sites (
  id uuid primary key default gen_random_uuid(),
  village_id uuid not null references public.villages(id) on delete restrict,
  street text not null,
  unit text,
  notes text,
  is_active boolean not null default true,
  created_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.crew_memberships (
  crew_id uuid not null references public.crews(id) on delete cascade,
  user_id uuid not null references public.profiles(user_id) on delete cascade,
  active_from date not null default current_date,
  active_to date,
  primary key (crew_id, user_id, active_from)
);

create table if not exists public.time_entries (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(user_id) on delete cascade,
  crew_id uuid references public.crews(id) on delete set null,
  village_id uuid references public.villages(id) on delete set null,
  job_site_id uuid references public.job_sites(id) on delete set null,
  clock_in_at timestamptz not null,
  clock_out_at timestamptz,
  total_minutes integer generated always as (
    case
      when clock_out_at is null then null
      else greatest(0, floor(extract(epoch from (clock_out_at - clock_in_at)) / 60)::int)
    end
  ) stored,
  source text not null default 'GODOT_APP',
  created_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_time_entries_user_day on public.time_entries(user_id, clock_in_at desc);

create table if not exists public.work_tickets (
  id uuid primary key default gen_random_uuid(),
  ticket_number bigint generated by default as identity unique,
  created_by uuid not null references public.profiles(user_id) on delete restrict,
  village_id uuid not null references public.villages(id) on delete restrict,
  job_site_id uuid not null references public.job_sites(id) on delete restrict,
  crew_id uuid references public.crews(id) on delete set null,
  crew_lead_id uuid references public.profiles(user_id) on delete set null,
  status public.ticket_status not null default 'TODO',
  work_type public.work_type not null,
  title text not null,
  notes text,
  started_at timestamptz,
  completed_at timestamptz,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.work_ticket_assignments (
  ticket_id uuid not null references public.work_tickets(id) on delete cascade,
  employee_id uuid not null references public.profiles(user_id) on delete cascade,
  assigned_at timestamptz not null default timezone('utc', now()),
  assigned_by uuid not null references public.profiles(user_id) on delete restrict,
  primary key(ticket_id, employee_id)
);

create table if not exists public.work_ticket_photos (
  id uuid primary key default gen_random_uuid(),
  ticket_id uuid not null references public.work_tickets(id) on delete cascade,
  uploaded_by uuid not null references public.profiles(user_id) on delete restrict,
  storage_path text not null,
  caption text,
  created_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.equipment_items (
  id uuid primary key default gen_random_uuid(),
  sku text unique,
  name text not null,
  category public.equipment_category not null,
  serial_number text,
  condition_status public.equipment_condition not null default 'GOOD',
  current_holder_user_id uuid references public.profiles(user_id) on delete set null,
  location_note text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.equipment_checkout_logs (
  id uuid primary key default gen_random_uuid(),
  equipment_item_id uuid not null references public.equipment_items(id) on delete cascade,
  action text not null check (action in ('CHECK_OUT', 'CHECK_IN', 'CONDITION_UPDATE')),
  acted_by uuid not null references public.profiles(user_id) on delete restrict,
  holder_user_id uuid references public.profiles(user_id) on delete set null,
  condition_status public.equipment_condition,
  note text,
  acted_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_equipment_logs_item_time on public.equipment_checkout_logs(equipment_item_id, acted_at desc);

create table if not exists public.repair_tickets (
  id uuid primary key default gen_random_uuid(),
  created_by uuid not null references public.profiles(user_id) on delete restrict,
  equipment_item_id uuid references public.equipment_items(id) on delete set null,
  title text not null,
  description text not null,
  status public.repair_status not null default 'OPEN',
  assigned_mechanic_id uuid references public.profiles(user_id) on delete set null,
  resolution_notes text,
  resolved_at timestamptz,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.repair_ticket_photos (
  id uuid primary key default gen_random_uuid(),
  repair_ticket_id uuid not null references public.repair_tickets(id) on delete cascade,
  uploaded_by uuid not null references public.profiles(user_id) on delete restrict,
  storage_path text not null,
  caption text,
  created_at timestamptz not null default timezone('utc', now())
);

-- Generic updated_at trigger
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = timezone('utc', now());
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_profiles_set_updated_at on public.profiles;
create trigger trg_profiles_set_updated_at before update on public.profiles
for each row execute function public.set_updated_at();

drop trigger if exists trg_work_tickets_set_updated_at on public.work_tickets;
create trigger trg_work_tickets_set_updated_at before update on public.work_tickets
for each row execute function public.set_updated_at();

drop trigger if exists trg_equipment_items_set_updated_at on public.equipment_items;
create trigger trg_equipment_items_set_updated_at before update on public.equipment_items
for each row execute function public.set_updated_at();

drop trigger if exists trg_repair_tickets_set_updated_at on public.repair_tickets;
create trigger trg_repair_tickets_set_updated_at before update on public.repair_tickets
for each row execute function public.set_updated_at();

-- Role helper functions for RLS
create or replace function public.current_role()
returns public.app_role
language sql
stable
as $$
  select role from public.profiles where user_id = auth.uid();
$$;

create or replace function public.has_any_role(roles public.app_role[])
returns boolean
language sql
stable
as $$
  select coalesce(public.current_role() = any(roles), false);
$$;

-- Enable RLS
alter table public.profiles enable row level security;
alter table public.crews enable row level security;
alter table public.villages enable row level security;
alter table public.job_sites enable row level security;
alter table public.crew_memberships enable row level security;
alter table public.time_entries enable row level security;
alter table public.work_tickets enable row level security;
alter table public.work_ticket_assignments enable row level security;
alter table public.work_ticket_photos enable row level security;
alter table public.equipment_items enable row level security;
alter table public.equipment_checkout_logs enable row level security;
alter table public.repair_tickets enable row level security;
alter table public.repair_ticket_photos enable row level security;

-- Policies
create policy "profiles self or admin read"
on public.profiles for select
using (auth.uid() = user_id or public.has_any_role(array['ADMIN']::public.app_role[]));

create policy "profiles admin write"
on public.profiles for all
using (public.has_any_role(array['ADMIN']::public.app_role[]))
with check (public.has_any_role(array['ADMIN']::public.app_role[]));

create policy "reference data readable by authenticated"
on public.villages for select
using (auth.uid() is not null);

create policy "reference data admin manage villages"
on public.villages for all
using (public.has_any_role(array['ADMIN']::public.app_role[]))
with check (public.has_any_role(array['ADMIN']::public.app_role[]));

create policy "reference data readable job sites"
on public.job_sites for select
using (auth.uid() is not null);

create policy "reference data admin manage job sites"
on public.job_sites for all
using (public.has_any_role(array['ADMIN']::public.app_role[]))
with check (public.has_any_role(array['ADMIN']::public.app_role[]));

create policy "crews readable by authenticated"
on public.crews for select
using (auth.uid() is not null);

create policy "crews admin manage"
on public.crews for all
using (public.has_any_role(array['ADMIN']::public.app_role[]))
with check (public.has_any_role(array['ADMIN']::public.app_role[]));

create policy "crew membership readable by authenticated"
on public.crew_memberships for select
using (auth.uid() is not null);

create policy "crew membership admin manage"
on public.crew_memberships for all
using (public.has_any_role(array['ADMIN']::public.app_role[]))
with check (public.has_any_role(array['ADMIN']::public.app_role[]));

create policy "time entries read own or lead/admin"
on public.time_entries for select
using (
  auth.uid() = user_id
  or public.has_any_role(array['ADMIN', 'CREW_LEAD']::public.app_role[])
);

create policy "time entries insert own or lead/admin"
on public.time_entries for insert
with check (
  auth.uid() = user_id
  or public.has_any_role(array['ADMIN', 'CREW_LEAD']::public.app_role[])
);

create policy "time entries update own open or admin"
on public.time_entries for update
using (
  (auth.uid() = user_id and clock_out_at is null)
  or public.has_any_role(array['ADMIN', 'CREW_LEAD']::public.app_role[])
)
with check (
  auth.uid() = user_id
  or public.has_any_role(array['ADMIN', 'CREW_LEAD']::public.app_role[])
);

create policy "work tickets read authenticated"
on public.work_tickets for select
using (auth.uid() is not null);

create policy "work tickets create lead/admin"
on public.work_tickets for insert
with check (public.has_any_role(array['ADMIN', 'CREW_LEAD']::public.app_role[]));

create policy "work tickets update lead admin mechanic"
on public.work_tickets for update
using (public.has_any_role(array['ADMIN', 'CREW_LEAD', 'MECHANIC']::public.app_role[]))
with check (public.has_any_role(array['ADMIN', 'CREW_LEAD', 'MECHANIC']::public.app_role[]));

create policy "work assignment read authenticated"
on public.work_ticket_assignments for select
using (auth.uid() is not null);

create policy "work assignment manage lead/admin"
on public.work_ticket_assignments for all
using (public.has_any_role(array['ADMIN', 'CREW_LEAD']::public.app_role[]))
with check (public.has_any_role(array['ADMIN', 'CREW_LEAD']::public.app_role[]));

create policy "work photos read authenticated"
on public.work_ticket_photos for select
using (auth.uid() is not null);

create policy "work photos insert ticket workers"
on public.work_ticket_photos for insert
with check (auth.uid() = uploaded_by);

create policy "equipment read authenticated"
on public.equipment_items for select
using (auth.uid() is not null);

create policy "equipment update lead mechanic admin"
on public.equipment_items for update
using (public.has_any_role(array['ADMIN', 'CREW_LEAD', 'MECHANIC']::public.app_role[]))
with check (public.has_any_role(array['ADMIN', 'CREW_LEAD', 'MECHANIC']::public.app_role[]));

create policy "equipment create admin mechanic"
on public.equipment_items for insert
with check (public.has_any_role(array['ADMIN', 'MECHANIC']::public.app_role[]));

create policy "equipment logs read authenticated"
on public.equipment_checkout_logs for select
using (auth.uid() is not null);

create policy "equipment logs insert lead mechanic admin"
on public.equipment_checkout_logs for insert
with check (public.has_any_role(array['ADMIN', 'CREW_LEAD', 'MECHANIC']::public.app_role[]));

create policy "repair tickets read authenticated"
on public.repair_tickets for select
using (auth.uid() is not null);

create policy "repair tickets insert authenticated"
on public.repair_tickets for insert
with check (auth.uid() = created_by);

create policy "repair tickets update mechanic admin"
on public.repair_tickets for update
using (public.has_any_role(array['ADMIN', 'MECHANIC']::public.app_role[]))
with check (public.has_any_role(array['ADMIN', 'MECHANIC']::public.app_role[]));

create policy "repair photos read authenticated"
on public.repair_ticket_photos for select
using (auth.uid() is not null);

create policy "repair photos insert authenticated"
on public.repair_ticket_photos for insert
with check (auth.uid() = uploaded_by);

-- Storage buckets
insert into storage.buckets (id, name, public)
values
  ('work-ticket-photos', 'work-ticket-photos', false),
  ('repair-photos', 'repair-photos', false)
on conflict (id) do nothing;

-- Storage policies
create policy "work ticket photos access authenticated"
on storage.objects for select
using (bucket_id = 'work-ticket-photos' and auth.uid() is not null);

create policy "work ticket photos upload authenticated"
on storage.objects for insert
with check (bucket_id = 'work-ticket-photos' and auth.uid() is not null);

create policy "repair photos access authenticated"
on storage.objects for select
using (bucket_id = 'repair-photos' and auth.uid() is not null);

create policy "repair photos upload authenticated"
on storage.objects for insert
with check (bucket_id = 'repair-photos' and auth.uid() is not null);
